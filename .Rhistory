is.character(variables))
stopifnot("Not all variables are present in A." =
all(variables %in% names(A)))
stopifnot("Not all variables are present in B." =
all(variables %in% names(B)))
if (!is.null(comparators)) {
stopifnot("`comparators` should be a list." =
is.list(comparators))
}
if (!is.null(matches)) {
stopifnot("`matches` should be a data.frame or a data.table." =
is.data.frame(matches) | is.data.table(matches))
stopifnot("`matches` should consist of two columns: a, b." =
length(colnames(matches)) == 2,
all(colnames(matches) == c("a", "b")))
}
K <- length(variables)
missing_variables <- variables[!(variables %in% names(comparators))]
comparators[missing_variables] <- rep(list(reclin2::cmp_identical()),
length(missing_variables))
data.table::setDT(A)
data.table::setDT(B)
A <- A[, ..variables]
B <- B[, ..variables]
A[, a := .I]
B[, b := .I]
Omega <- data.table::CJ(a = A$a, b = B$b)
setkey(Omega, NULL)
A_values <- A[Omega$a, ]
B_values <- B[Omega$b, ]
A_values[, a := NULL]
B_values[, b := NULL]
gamma_names <- paste0("gamma_", variables)
gamma_list <- lapply(1:K, function(x) {
variable <- variables[x]
return(as.numeric(comparators[[x]](A_values[[variable]], B_values[[variable]])))
})
Omega[, (gamma_names) := gamma_list]
if(!is.null(matches)) {
Omega[, match := as.numeric(paste(a, b) %in% paste(matches$a, matches$b))]
}
structure(
list(
Omega = data.table(Omega),
variables = variables,
comparators = comparators
),
class = "comparison_vectors"
)
}
#' Creates a function that calculates the absolute distance between two values.
#'
#' @return
#' Returns a function taking two arguments, `x` and `y`, and returning their absolute difference.
#'
#' @examples
#' cmp <- abs_distance()
#' cmp(1, 5) # returns 4
#'
#' @export
abs_distance <- function() {
function(x, y) {
abs(x - y)
}
}
comparison_vectors(A = df_1, B = df_2, variables = c("name", "surname"),
comparators = comparators, matches = matches)
df_1 <- data.frame(
"name" = c("John", "Emily", "Mark", "Anna", "David"),
"surname" = c("Smith", "Johnson", "Taylor", "Williams", "Brown")
)
df_2 <- data.frame(
"name" = c("Jon", "Emely", "Marc", "Michael"),
"surname" = c("Smitth", "Jonson", "Tailor", "Henderson")
)
comparators <- list("name" = reclin2::cmp_jarowinkler(),
"surname" = reclin2::cmp_jarowinkler())
matches <- data.frame("a" = 1:3, "b" = 1:3)
methods <- list("name" = "continuous_nonparametric",
"surname" = "continuous_nonparametric")
comparison_vectors(A = df_1, B = df_2, variables = c("name", "surname"),
comparators = comparators, matches = matches)
result <- comparison_vectors(A = df_1, B = df_2, variables = c("name", "surname"),
comparators = comparators, matches = matches)
result
result$Omega
library(xgboost)
train_data <- xgb.DMatrix(data = as.matrix(result[, c("gamma_name", "gamma_surname")]),
label = result$match)
as.matrix(result[, c("gamma_name", "gamma_surname")])
as.matrix(result$Omega[, c("gamma_name", "gamma_surname")]
)
train_data <- xgb.DMatrix(data = as.matrix(result$Omega[, c("gamma_name", "gamma_surname")]),
label = result$match)
result$Omega$match
train_data <- xgb.DMatrix(data = as.matrix(result$Omega[, c("gamma_name", "gamma_surname")]),
label = result$Omega$match)
train_data
params <- list(objective = "binary:logistic",
eval_metric = "logloss")
xgb_model <- xgboost(data = train_datan, params = params,
nrounds = 50,
verbose = 0)
xgb_model <- xgboost(data = train_data, params = params,
nrounds = 50, verbose = 0)
xgb_model
predict(model, df_1, df_2)
predict(xgb_model, df_1, df_2)
custom_model <- custom_rec_lin_model(xgb_model, result)
predict(custom_model, df_1, df_2)
predict(custom_model, df_1, df_2)
#' @import data.table
#' @importFrom stats dbinom
#' @importFrom FixedPoint FixedPoint
#'
#' @title Predict matches based on a given record linkage model
#'
#' @export
predict.rec_lin_model <- function(object,
newdata_A,
newdata_B,
set_construction = c("size", "flr"),
fixed_method = "Newton",
target_flr = 0.05,
tol = 10^(-3),
max_iter = 1000,
...) {
stopifnot("`newdata_A` is required for predictions." =
!missing(newdata_A))
stopifnot("`newdata_B` is required for predictions." =
!missing(newdata_B))
stopifnot("`set_construction` should be `size` or `flr`." =
set_construction %in% c("size", "flr"))
if (missing(set_construction)) set_construction <- "size"
vectors <- comparison_vectors(A = newdata_A,
B = newdata_B,
variables = object$variables,
comparators = object$comparators)
Omega <- vectors$Omega
n <- NROW(Omega)
if (!is.null(object$ml_model)) {
# predicted_probs <- do.call(
#   predict,
#   c(list(
#     object$ml_model,
#     Omega
#   ),
#   controls_ml_predictions)
# )
predicted_probs <- predict(object$model,
Omega,
...)
Omega[, "ratio" := predicted_probs]
} else {
Omega[, "ratio" := 1]
if (!is.null(object$binary_variables)) {
binary_variables <- object$binary_variables
binary_params <- object$binary_params
Omega_binary <- Omega[, ..binary_variables]
binary_numerator_list <- lapply(binary_variables,
function(col) {
stats::dbinom(x = Omega_binary[[col]],
size = 1,
prob = as.numeric(binary_params[variable == col, "theta"]))
})
binary_numerator <- Reduce(`*`, binary_numerator_list)
binary_denominator_list <- lapply(binary_variables,
function(col) {
stats::dbinom(x = Omega_binary[[col]],
size = 1,
prob = as.numeric(binary_params[variable == col, "eta"]))
})
binary_denominator <- Reduce(`*`, binary_denominator_list)
Omega[, ratio := ratio * binary_numerator / binary_denominator]
}
if (!is.null(object$continuous_parametric_variables)) {
continuous_parametric_variables <- object$continuous_parametric_variables
continuous_parametric_params <- object$continuous_parametric_params
Omega_continuous_parametric <- Omega[, ..continuous_parametric_variables]
continuous_parametric_numerator_list <- lapply(continuous_parametric_variables,
function(col) {
hurdle_gamma_density(x = Omega_continuous_parametric[[col]],
p_0 = as.numeric(continuous_parametric_params[variable == col, "p_0_M"]),
alpha = as.numeric(continuous_parametric_params[variable == col, "alpha_M"]),
beta = as.numeric(continuous_parametric_params[variable == col, "beta_M"]))
})
continuous_parametric_numerator <- Reduce(`*`, continuous_parametric_numerator_list)
continuous_parametric_denominator_list <- lapply(continuous_parametric_variables,
function(col) {
hurdle_gamma_density(x = Omega_continuous_parametric[[col]],
p_0 = as.numeric(continuous_parametric_params[variable == col, "p_0_U"]),
alpha = as.numeric(continuous_parametric_params[variable == col, "alpha_U"]),
beta = as.numeric(continuous_parametric_params[variable == col, "beta_U"]))
})
continuous_parametric_denominator <- Reduce(`*`, continuous_parametric_denominator_list)
Omega[, ratio := ratio * continuous_parametric_numerator / continuous_parametric_denominator]
}
if (!is.null(object$continuous_nonparametric_variables)) {
continuous_nonparametric_variables <- object$continuous_nonparametric_variables
ratio_kliep <- object$ratio_kliep
Omega_continuous_nonparametric <- Omega[, ..continuous_nonparametric_variables]
Omega[, ratio := ratio * predict(ratio_kliep, Omega_continuous_nonparametric)]
}
}
n_M_start <- NROW(merge(newdata_A, newdata_B, by = object$variables, all = FALSE))
fun_n_M <- fixed_n_M(n = n, ratio_gamma = Omega$ratio)
n_M_est <- min(FixedPoint::FixedPoint(Function = fun_n_M, # to think
Inputs = n_M_start,
Method = fixed_method)$FixedPoint,
min(NROW(newdata_A), NROW(newdata_B)))
n_M_est <- max(n_M_est, 0)
if (set_construction == "size") {
# n_M_start <- NROW(merge(newdata_A, newdata_B, by = object$variables, all = FALSE))
# fun_n_M <- fixed_n_M(n = n, ratio_gamma = Omega$ratio)
# n_M_est <- min(FixedPoint::FixedPoint(Function = fun_n_M, # to think
#                                       Inputs = n_M_start,
#                                       Method = fixed_method)$FixedPoint,
#                min(NROW(newdata_A), NROW(newdata_B)))
# n_M_est <- max(n_M_est, 0)
Omega <- Omega[order(-ratio), ]
M_est <- data.table("a" = numeric(), "b" = numeric(), "ratio" = numeric())
used_a <- c()
used_b <- c()
for (i in 1:NROW(Omega)) {
current_a <- Omega$a[i]
current_b <- Omega$b[i]
if (!(current_a %in% used_a) && !(current_b %in% used_b)) {
M_est <- rbind(M_est, Omega[i, c("a", "b", "ratio")])
used_a <- c(used_a, current_a)
used_b <- c(used_b, current_b)
}
}
g_est <- pmin(NROW(M_est) * M_est$ratio / (NROW(M_est) * (M_est$ratio - 1) + n), 1)
flr_est <- 1 / NROW(M_est) * sum(1 - g_est)
it <- NULL
} else if (set_construction == "flr") {
Omega <- Omega[order(-ratio), ]
min_treshold <- min(Omega$ratio)
max_treshold <- max(Omega$ratio)
treshold <- (min_treshold + max_treshold) / 2
it <- 0
while (it < max_iter) {
M_est <- Omega[ratio >= treshold, ]
g_est <- pmin(NROW(M_est) * M_est$ratio / (NROW(M_est) * (M_est$ratio - 1) + n), 1)
flr_est <- 1 / NROW(M_est) * sum(1 - g_est)
if (abs(flr_est - target_flr) <= tol) {
break
} else if (flr_est < target_flr) {
max_treshold <- treshold
treshold <- (min_treshold + max_treshold) / 2
} else {
min_treshold <- treshold
treshold <- (min_treshold + max_treshold) / 2
}
it <- it + 1
}
}
mmr_est <- 1 - sum(g_est / n_M_est)
M_est <- M_est[, c("a", "b")]
structure(
list(
M_est = M_est,
set_construction = set_construction,
flr_est = flr_est,
mmr_est = mmr_est,
it = if (is.null(it)) NULL else it
),
class = "rec_lin_predictions"
)
}
binary_formula <- function(df) {
par <- apply(df, 2, mean)
par
}
p_0_formula <- function(df) {
par <- apply(df, 2, function(x) {
x <- x[x == 0]
length(x) / NROW(df)
})
par
}
f_alpha <- function(alpha, gamma) {
gamma <- gamma[gamma > 0]
gamma_mean <- mean(gamma)
sum(log(gamma) - log(gamma_mean) - digamma(alpha) + log(alpha))
}
gamma_plus_formula <- function(df) {
par <- apply(df, 2, function(x) {
x <- x[x > 0]
mean(x)
})
par
}
alpha_formula <- function(df, fun) {
par <- apply(df, 2, function(y) {
fun(x = 1, fn = f_alpha, gamma = y, method = "Newton")$x
})
par
}
#' @importFrom stats dgamma
hurdle_gamma_density <- function(x, p_0, alpha, beta) {
ifelse(x == 0, p_0, 1) *
ifelse(x > 0, (1 - p_0) * stats::dgamma(x = x, shape = alpha, scale = 1 / beta), 1)
}
fixed_n_M <- function(n, ratio_gamma) {
function(n_M) {
sum(n_M * ratio_gamma / (n_M * (ratio_gamma - 1) + n))
}
}
#'
#' @param scale `"numerator"`, `"denominator"` or `NULL`, indicating whether to standardize each numeric variable according
#' to the numerator means and standard deviations, the denominator means and standard deviations,
#' or apply no standardization at all.
#' @param ... Additional arguments.
#'
#' @return
#' Returns a list with parameters.
#'
#' @export
control_kliep <- function(scale = NULL,
...) {
append(list(scale = scale),
list(...))
}
predict(custom_model, df_1, df_2)
custom_model
View(custom_model)
#' @import data.table
#' @importFrom stats dbinom
#' @importFrom FixedPoint FixedPoint
#'
#' @title Predict matches based on a given record linkage model
#'
#' @export
predict.rec_lin_model <- function(object,
newdata_A,
newdata_B,
set_construction = c("size", "flr"),
fixed_method = "Newton",
target_flr = 0.05,
tol = 10^(-3),
max_iter = 1000,
...) {
stopifnot("`newdata_A` is required for predictions." =
!missing(newdata_A))
stopifnot("`newdata_B` is required for predictions." =
!missing(newdata_B))
stopifnot("`set_construction` should be `size` or `flr`." =
set_construction %in% c("size", "flr"))
if (missing(set_construction)) set_construction <- "size"
vectors <- comparison_vectors(A = newdata_A,
B = newdata_B,
variables = object$variables,
comparators = object$comparators)
Omega <- vectors$Omega
n <- NROW(Omega)
if (!is.null(object$ml_model)) {
# predicted_probs <- do.call(
#   predict,
#   c(list(
#     object$ml_model,
#     Omega
#   ),
#   controls_ml_predictions)
# )
predicted_probs <- predict(object$ml_model,
Omega,
...)
Omega[, "ratio" := predicted_probs]
} else {
Omega[, "ratio" := 1]
if (!is.null(object$binary_variables)) {
binary_variables <- object$binary_variables
binary_params <- object$binary_params
Omega_binary <- Omega[, ..binary_variables]
binary_numerator_list <- lapply(binary_variables,
function(col) {
stats::dbinom(x = Omega_binary[[col]],
size = 1,
prob = as.numeric(binary_params[variable == col, "theta"]))
})
binary_numerator <- Reduce(`*`, binary_numerator_list)
binary_denominator_list <- lapply(binary_variables,
function(col) {
stats::dbinom(x = Omega_binary[[col]],
size = 1,
prob = as.numeric(binary_params[variable == col, "eta"]))
})
binary_denominator <- Reduce(`*`, binary_denominator_list)
Omega[, ratio := ratio * binary_numerator / binary_denominator]
}
if (!is.null(object$continuous_parametric_variables)) {
continuous_parametric_variables <- object$continuous_parametric_variables
continuous_parametric_params <- object$continuous_parametric_params
Omega_continuous_parametric <- Omega[, ..continuous_parametric_variables]
continuous_parametric_numerator_list <- lapply(continuous_parametric_variables,
function(col) {
hurdle_gamma_density(x = Omega_continuous_parametric[[col]],
p_0 = as.numeric(continuous_parametric_params[variable == col, "p_0_M"]),
alpha = as.numeric(continuous_parametric_params[variable == col, "alpha_M"]),
beta = as.numeric(continuous_parametric_params[variable == col, "beta_M"]))
})
continuous_parametric_numerator <- Reduce(`*`, continuous_parametric_numerator_list)
continuous_parametric_denominator_list <- lapply(continuous_parametric_variables,
function(col) {
hurdle_gamma_density(x = Omega_continuous_parametric[[col]],
p_0 = as.numeric(continuous_parametric_params[variable == col, "p_0_U"]),
alpha = as.numeric(continuous_parametric_params[variable == col, "alpha_U"]),
beta = as.numeric(continuous_parametric_params[variable == col, "beta_U"]))
})
continuous_parametric_denominator <- Reduce(`*`, continuous_parametric_denominator_list)
Omega[, ratio := ratio * continuous_parametric_numerator / continuous_parametric_denominator]
}
if (!is.null(object$continuous_nonparametric_variables)) {
continuous_nonparametric_variables <- object$continuous_nonparametric_variables
ratio_kliep <- object$ratio_kliep
Omega_continuous_nonparametric <- Omega[, ..continuous_nonparametric_variables]
Omega[, ratio := ratio * predict(ratio_kliep, Omega_continuous_nonparametric)]
}
}
n_M_start <- NROW(merge(newdata_A, newdata_B, by = object$variables, all = FALSE))
fun_n_M <- fixed_n_M(n = n, ratio_gamma = Omega$ratio)
n_M_est <- min(FixedPoint::FixedPoint(Function = fun_n_M, # to think
Inputs = n_M_start,
Method = fixed_method)$FixedPoint,
min(NROW(newdata_A), NROW(newdata_B)))
n_M_est <- max(n_M_est, 0)
if (set_construction == "size") {
# n_M_start <- NROW(merge(newdata_A, newdata_B, by = object$variables, all = FALSE))
# fun_n_M <- fixed_n_M(n = n, ratio_gamma = Omega$ratio)
# n_M_est <- min(FixedPoint::FixedPoint(Function = fun_n_M, # to think
#                                       Inputs = n_M_start,
#                                       Method = fixed_method)$FixedPoint,
#                min(NROW(newdata_A), NROW(newdata_B)))
# n_M_est <- max(n_M_est, 0)
Omega <- Omega[order(-ratio), ]
M_est <- data.table("a" = numeric(), "b" = numeric(), "ratio" = numeric())
used_a <- c()
used_b <- c()
for (i in 1:NROW(Omega)) {
current_a <- Omega$a[i]
current_b <- Omega$b[i]
if (!(current_a %in% used_a) && !(current_b %in% used_b)) {
M_est <- rbind(M_est, Omega[i, c("a", "b", "ratio")])
used_a <- c(used_a, current_a)
used_b <- c(used_b, current_b)
}
}
g_est <- pmin(NROW(M_est) * M_est$ratio / (NROW(M_est) * (M_est$ratio - 1) + n), 1)
flr_est <- 1 / NROW(M_est) * sum(1 - g_est)
it <- NULL
} else if (set_construction == "flr") {
Omega <- Omega[order(-ratio), ]
min_treshold <- min(Omega$ratio)
max_treshold <- max(Omega$ratio)
treshold <- (min_treshold + max_treshold) / 2
it <- 0
while (it < max_iter) {
M_est <- Omega[ratio >= treshold, ]
g_est <- pmin(NROW(M_est) * M_est$ratio / (NROW(M_est) * (M_est$ratio - 1) + n), 1)
flr_est <- 1 / NROW(M_est) * sum(1 - g_est)
if (abs(flr_est - target_flr) <= tol) {
break
} else if (flr_est < target_flr) {
max_treshold <- treshold
treshold <- (min_treshold + max_treshold) / 2
} else {
min_treshold <- treshold
treshold <- (min_treshold + max_treshold) / 2
}
it <- it + 1
}
}
mmr_est <- 1 - sum(g_est / n_M_est)
M_est <- M_est[, c("a", "b")]
structure(
list(
M_est = M_est,
set_construction = set_construction,
flr_est = flr_est,
mmr_est = mmr_est,
it = if (is.null(it)) NULL else it
),
class = "rec_lin_predictions"
)
}
predict(custom_model, df_1, df_2)
devtools::document()
devtools::document()
dt <- data.table(
a = c(1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5),
b = c(1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4),
gamma_name = c(0.9166667,0,0,0.4642857,0,0.8666667,0,0.4476190,0,0,0.8333333,0.4642857,
0.5277778,0,0,0.4642857,0,0,0.4833333,0.4476190),
gamma_surname = c(0.9444444,0,0.4555556,0,0,0.9523810,0.4365079,0.6719577,0,0.4444444,0.8888889,0.3518519,
0.4305556,0,0.5277778,0.4120370,0,0.5777778,0.4555556,0.4370370),
match = c(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0)
)
# 2. Cechy i etykiety
X <- as.matrix(dt[, .(gamma_name, gamma_surname)])
y <- dt$match
# 3. DMatrix
dtrain <- xgb.DMatrix(data = X, label = y)
# 4. Trening
params <- list(objective = "binary:logistic", eval_metric = "logloss")
model <- xgboost(params = params, data = dtrain, nrounds = 50, verbose = 0)
# 5. Predykcja
dt[, predicted_prob := predict(model, X)]
print(dt)
# 5. Predykcja
dt[, predicted_prob := predict(xgb_model, X)]
devtools::document()
